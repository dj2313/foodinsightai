import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../auth/auth_providers.dart';
import '../../common/models/recipe.dart';

final recipeRepositoryProvider = Provider<RecipeRepository>((ref) {
  return RecipeRepository(ref.watch(firestoreProvider));
});

class RecipeRepository {
  final FirebaseFirestore _firestore;

  RecipeRepository(this._firestore);

  Stream<List<Recipe>> watchSavedRecipes(String uid) {
    return _firestore
        .collection('users')
        .doc(uid)
        .collection('recipes')
        .orderBy('title')
        .snapshots()
        .map((snapshot) {
          return snapshot.docs.map((doc) {
            return Recipe.fromMap(doc.data(), doc.id);
          }).toList();
        });
  }

  Future<void> saveRecipe(String uid, Recipe recipe) async {
    // If recipe is new, it might not have a proper ID or we want to force a new one.
    // Generally, recipes generated by Chef might have a temp ID or none.
    // We'll generate a new ID here to ensure uniqueness in Firestore.

    final ref = _firestore
        .collection('users')
        .doc(uid)
        .collection('recipes')
        .doc();

    // Recreate with Firestore ID
    final newRecipe = Recipe(
      id: ref.id,
      title: recipe.title,
      imageUrl: recipe.imageUrl,
      durationMinutes: recipe.durationMinutes,
      calories: recipe.calories,
      tags: recipe.tags,
      matchedPantryItems: recipe.matchedPantryItems,
      ingredients: recipe.ingredients,
      instructions: recipe.instructions,
      nutrition: recipe.nutrition,
    );

    await ref.set(newRecipe.toMap());
  }

  Future<void> deleteRecipe(String uid, String recipeId) async {
    await _firestore
        .collection('users')
        .doc(uid)
        .collection('recipes')
        .doc(recipeId)
        .delete();
  }
}
